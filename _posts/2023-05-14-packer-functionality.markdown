---
layout: single
title:  "Packer Functionality"
# date:   2024-06-01 16:44:45 -0500
categories: "Malware-Analysis"
toc: true
author_profile: true
classes: wide
---

# Software Packers
In this post we'll delve into what packers are and how malware authors use their functionality to their benefit.

## What is a Packer? 
A **packer**, in its simplest form, can be thought of as a self-extracting that was initially used to compress an executable file. Packers allowed for smaller file sizes while still being easy to use. A packed file remains executable, so end users do not have to manually unpack the file before being able to execute it. However, as a consequence of the packing process, the original contents get obfuscated and are not observable statically. While packers are not inheretly malicious, this is attractive to malware authors as it helps avoid detection. Packers have since grown in sophistication with added features to better defend against analysis and reverse engineering.

There are legitimate packers such as UPX and Themida. They are used by real programs to protect against reverse engineering and tampering with the program. 
Malicious packers main purpose is antivirus evasion. 

Today packers go by many different names which reflect their specialized functionality. This includes:
- **Crypter** - encrypts the original target file to prevent reverse engineering and evade ant-ivirus.
- **Protector** - both compresses and encrypts the target file. 

Understanding if a file was packed with a legitimate packer is simple. There are static analysis tools such as Detect-it-Easy, that can identify what packer was used. Malicious packers will usually not self identify, but if they do it will make it easy to detect as malware.     

## Packing Process
Components:
- *taget file* - the file to be packed. 
- the *stub* - is another executable file and is also known as the envalope. It contains the unpacking mechanism and acts as a loader for the packed contents. 
	- Typically, the stub performs some type of injection.

![Packing Process](/assets/images/packing_process.jpeg)

1\. Provide the target file to the packer.

2\. The stub is either:
- provided to the packer.
- part of the packer.
- generated by the packer.

3\. The resulting compressed and/or encrypted target file is stored. output from the packer is the packed file.

### Execution Process for a Packed File

1\. Depending how the file was packed, the stub will:
- decompress the compressed portion, originally, this was the target file. This is now a poriton of the packed file being executed. 
- and/or decrypt the encrypted data within itself   

2\. Run the target file in memory. There are two main ways this is done:

2.1 Run the target file in the current process of the packed file.
- This is usually done by reserving a section that has enough empty space in memory to place the decrypted/decompressed portion into it. This kinds of sections have a raw size of 0, but have a big virtual size. 
- Most legit processes also do this. 

2.2	Run the target file in an other process.

2.2.1 Create a child process of itself.

2.2.2 Inject the decrypted/decompressed portion into this new child process. 

**How does the Stub know where the encrypted/compressed content is located?**
A common way this is done is by utilizing start and end markers. If the content is encrypted there will be a key or a key generation fucntion inside the stub as well. The decryption key or key generation function may be useful in writing static unpackers. ([Guide](https://www.gdatasoftware.com/blog/2019/01/31413-unpack-lpdinch-malware)) Other common placement of contents in the sub:
- end of the file (overlay) - or a fixed offset from the end.
- last section - this is useful as the size of this section can be easily expanded without it affecting other sections 
- PE Resources
- .NET resources
- huge base64 string containing the encrypted data.

### Binary Padding
Binary padding is used by packers to change small portions of the file randomly. This may be adding random data to the packed file. This inevitably changes the hash value of the packed file even if the stub and input file are the same. This method counters blacklisting by antivirus products.

### Unique Stub Generation (USG)
The packer implements mechanisms to create a unique stub for every packed file.  This is a polymorphic packer, although whether or not this is truely polymorphic is still contested. 
- This kind of packer, has a raw stub or stub pieces that it can modify to create many different possible variants. 
- This may be acomplished by shuffling instructions where order does not matter, or adding "junk instructions" in random places. 
- When compared to *binary padding*, USG also evades antivirus pattern detection. 

## Misconceptions about Packers

**Packers do not inject into compiled binaries.**
In other words, packers do not make it so that only parts of the target file are encrypted/compressed. Doing so is overly complicated for a packer. This is because making changes to a compiled binary requires detailed knowledge of the internal structures of that binary.
* Doing so is possible, but most malware does not do this for the purposes of evasion. Leaving parts unencrtypted or uncompressed makes evasion less likely to succeed. 
* An exception is viruses that may do this, but for other purposes.

**Scantime Crypters are not Packers**
* Scantime crypters are actually "builders" for malware droppers.  

**The following are not Polymorphic**
* Usage of Binary Padding
* When a packer carries hundreds or thousands of stubs that are used to pick one randomly from. This would actually be a oligomorphic crypter, because there are only a few predefined forms.   

## References:
- MalwareAnalysisForHedgehogs: [Malware Theory - Packers](https://youtu.be/ESLEf66EzDk)
