---
layout: single
title:  "Packer Functionality"
date:   2024-06-01 16:44:45 -0500
categories: Malware
toc: true
author_profile: true
classes: wide
---

# Packers

## What is a packer? 

A **packer** is a tool that was initially used to compress an executable file. There are three different types of packers:
**Compressor** - shrinks the size of the file to save space on disk. 
- For example, UPX is a compressor.
**Crypter** - encrypts the original target file to prevent reverse engineering and evade ant-ivirus.
**Protector** - both compresses and encrypts the target file. 

Today, packers are still used to compress/encrypt executables or DLL files. Packers themselves are not malicious; there are legit packers such as UPX and Themida. They are used by real programs to protect against reverse engineering and tampering with the program. 

These same protections are appealing to malware authors because:
- these protections serve as an anti-analysis technique for them, since they essentially obfuscate the content of the malware, making it difficult to analyze strings statically.
- Malicious packers main purpose is antivirus evasion. 

Note: This is an anlysis section may be moved to unpacking section in future?

Understanding if a file was packed with a legitimate packer is simple. There are static analysis tools such as Detect-it-Easy, that can identify what packer was used. Malicious packers will usually not self identify, but if they do it will make it easy to detect as malware.     

## Packing Process
Components:
- *taget file* - the file to be packed. 
- the *stub* - is another executable file and is also known as the envalope. It contains the unpacking mechanism and acts as a loader for the packed contents. 
	- Typically, the stub performs some type of injection.

![Packing Process](/assets/images/packing_process.jpeg)

1\. Provide the target file to the packer.

2\. The stub is either:
- provided to the packer.
- part of the packer.
- generated by the packer.

3\. The resulting compressed and/or encrypted target file is stored. output from the packer is the packed file.

### Execution Process for a Packed File

1\. Depending how the file was packed, the stub will:
- decompress the compressed portion, originally, this was the target file. This is now a poriton of the packed file being executed. 
- and/or decrypt the encrypted data within itself   

2\. Run the target file in memory. There are two main ways this is done:

2.1 Run the target file in the current process of the packed file.
- This is usually done by reserving a section that has enough empty space in memory to place the decrypted/decompressed portion into it. This kinds of sections have a raw size of 0, but have a big virtual size. 
- Most legit processes also do this. 

2.2	Run the target file in an other process.

2.2.1 Create a child process of itself.

2.2.2 Inject the decrypted/decompressed portion into this new child process. 

**How does the Stub know where the encrypted/compressed content is located?**
A common way this is done is by utilizing start and end markers. If the content is encrypted there will be a key or a key generation fucntion inside the stub as well. The decryption key or key generation function may be useful in writing static unpackers. ([Guide](https://www.gdatasoftware.com/blog/2019/01/31413-unpack-lpdinch-malware)) Other common placement of contents in the sub:
- end of the file (overlay) - or a fixed offset from the end.
- last section - this is useful as the size of this section can be easily expanded without it affecting other sections 
- PE Resources
- .NET resources
- huge base64 string containing the encrypted data.

### Binary Padding
Binary padding is used by packers to change small portions of the file randomly. This may be adding random data to the packed file. This inevitably changes the hash value of the packed file even if the stub and input file are the same. This method counters blacklisting by antivirus products.

### Unique Stub Generation (USG)
The packer implements mechanisms to create a unique stub for every packed file.  This is a polymorphic packer, although whether or not this is truely polymorphic is still contested. 
- This kind of packer, has a raw stub or stub pieces that it can modify to create many different possible variants. 
- This may be acomplished by shuffling instructions where order does not matter, or adding "junk instructions" in random places. 
- When compared to *binary padding*, USG also evades antivirus pattern detection. 

## Misconceptions about Packers

**Packers do not inject into compiled binaries.**
In other words, packers do not make it so that only parts of the target file are encrypted/compressed. Doing so is overly complicated for a packer. This is because making changes to a compiled binary requires detailed knowledge of the internal structures of that binary.
* Doing so is possible, but most malware does not do this for the purposes of evasion. Leaving parts unencrtypted or uncompressed makes evasion less likely to succeed. 
* An exception is viruses that may do this, but for other purposes.

**Scantime Crypters are not Packers**
* Scantime crypters are actually "builders" for malware droppers.  

**The following are not Polymorphic**
* Usage of Binary Padding
* When a packer carries hundreds or thousands of stubs that are used to pick one randomly from. This would actually be a oligomorphic crypter, because there are only a few predefined forms.   

Sources:
- Analysis for Hedgehogs: [Malware Theory - Packers](https://youtu.be/ESLEf66EzDk)
